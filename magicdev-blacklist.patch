--- magicdev-1.1.4/daemon.c.blacklist	2003-06-13 16:49:19.000000000 -0400
+++ magicdev-1.1.4/daemon.c	2003-06-13 16:51:20.000000000 -0400
@@ -19,6 +19,8 @@
 #include <sys/stat.h>
 #include <linux/iso_fs.h>
 #include <linux/cdrom.h>
+#include <stdarg.h>
+#include <string.h>
 #include <errno.h>
 
 #include <gdk/gdkx.h>
@@ -67,6 +69,7 @@
 
         char *fsname;
         char *fspath;
+        char *unaliased_device;
 
         gboolean is_mounted;
         gboolean did_mount;
@@ -147,6 +150,8 @@
 
 static void     cdrom_ioctl_frenzy      (int      fd);
 
+static gboolean verbose = FALSE;
+
  /* Like, access but a bit more accurate - access will let
   * root do anything. Does not get read-only or no-exec
   * filesystems right.
@@ -183,6 +188,23 @@
 }
 
 static void
+magicdev_verbose (const char *format,
+                  ...)
+{
+        if (verbose) {
+                va_list vap;
+                char *message;
+                
+                va_start (vap, format);
+                message = g_strdup_vprintf (format, vap);
+                va_end (vap);
+
+                g_printerr ("magicdev: %s\n", message);
+                g_free (message);
+        }
+}
+
+static void
 selection_get_func (GtkClipboard     *clipboard,
                     GtkSelectionData *selection_data,
                     guint             info,
@@ -296,14 +318,21 @@
         AppInfo *ai;
         GnomeClient *client;
 
+        static const struct poptOption popt_options [] = {
+                { "verbose", '\0', POPT_ARG_NONE, &verbose, 0,
+                  N_("Output verbose debugging information"), NULL },
+		POPT_TABLEEND
+        };
+
 	bindtextdomain (PACKAGE, GNOMELOCALEDIR);
 	bind_textdomain_codeset(PACKAGE, "UTF-8");
 	textdomain (PACKAGE);
 
 	gnome_program_init (PACKAGE, VERSION,
-			LIBGNOMEUI_MODULE,
-			argc, argv,
-			GNOME_PARAM_APP_DATADIR, DATADIR, NULL);
+                            LIBGNOMEUI_MODULE,
+                            argc, argv,
+                            GNOME_PARAM_POPT_TABLE, popt_options,
+                            GNOME_PARAM_APP_DATADIR, DATADIR, NULL);
 
 	client = gnome_master_client ();
 	if (magicdev_get_lock()) {
@@ -638,6 +667,61 @@
         g_free (ent);
 }
 
+static const char * const blacklisted_models[] = {
+        /* https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=73661 */
+        "HL-DT-STCD-RW/DVD-ROM GCC-4240N"
+};
+
+static gboolean
+app_device_is_blacklisted (DevInfo *info)
+{
+        gchar *basename;
+        gchar *procname = NULL;
+        gchar *model = NULL;
+        gboolean blacklisted = FALSE;
+
+        magicdev_verbose ("Checking for blacklisting of %s (%s)",
+                          info->fsname,
+                          info->unaliased_device);
+
+        basename = g_path_get_basename (info->unaliased_device);
+        if (basename[0] == 'h' && basename[1] == 'd') {
+                procname = g_build_filename ("/proc/ide", basename, "model", NULL);
+        }
+
+        if (procname)
+                g_file_get_contents (procname, &model, NULL, NULL);
+
+        if (model) {
+                int i;
+
+                if (verbose) {
+                        char *p = model + strlen (model);
+                        while (p > model && g_ascii_isspace (p[-1])) {
+                                p[-1] = '\0';
+                                p--;
+                        }
+                        magicdev_verbose ("Model is %s (from %s)", model, procname);
+                }
+
+                for (i = 0; i < G_N_ELEMENTS(blacklisted_models); i++) {
+                        if (strstr (model, blacklisted_models[i]) != NULL)
+                                blacklisted = TRUE;
+                }
+
+                magicdev_verbose ("%s",
+                                  blacklisted ? "Blacklisted" : "Not blacklisted");
+                        
+        } else {
+                magicdev_verbose ("Could not retrieve model");
+        }
+
+        g_free (model);
+        g_free (procname);
+
+        return blacklisted;
+}
+
 static void
 app_device_add (AppInfo       *ai,
                 struct mntent *ent)
@@ -662,6 +746,11 @@
 
         ai->devices = g_list_append (ai->devices, newdev);
         app_device_add_aliases (ai, g_strdup (newdev->fsname), newdev);
+        if (app_device_is_blacklisted (newdev)) {
+                app_device_remove (ai, newdev);
+                return;
+        }
+        
 #ifdef MD_DEBUG
         g_message ("Device %s came through (type %s)", newdev->fsname, type_names[newdev->type]);
 #endif
@@ -672,6 +761,7 @@
                 close (newdev->fd);
                 g_free (newdev->fsname);
                 g_free (newdev->fspath);
+                g_free (newdev->unaliased_device);
         }
         g_free (newdev);
 }
@@ -700,6 +790,7 @@
                 close (info->fd);
         g_free (info->fsname);
         g_free (info->fspath);
+        g_free (info->unaliased_device);
 
         g_free (info);
 }
@@ -718,8 +809,10 @@
         g_hash_table_insert (ai->devs_by_fsname, (gpointer)alias, dev);
 
         buflen = readlink (alias, buf, sizeof (buf));
-        if (buflen < 1)
+        if (buflen < 1) {
+                dev->unaliased_device = g_strdup (alias);
                 return;
+        }
 
         buf[buflen] = '\0';
 
